"""
Test data  development for EEG quality assessment using the Laurel Place dataset 
features extractd from the data:

The dataset from this script is class labelled using the EQI (for disqualified scans) and the similarity index (for accepted scans and disqualified scans)
The dataset from this script is based on just channel cz features per subjects

The dataset from this script can be used for the following:
1. trainDataPrep_1.0.py: drop all fz and pz features in trainDataPrep_1.0.py when using this script
2. trainDataPrep_1.1.py: no need to drop any features in trainDataPrep_1.1.py when using this script

The features generated by this script are:
1. RMS
2. kurtosis
3. sample entropy
4. app entropy
5. RMS bandpass filtered
"""


from fn_cfg import *
import params as cfg

def multipleRawEEG(device_version,scan_IDs,local_path,fs,line,lowcut,highcut):
    def fnc(device_version,scan_ID,local_path,fs,line,lowcut,highcut):
        device = importFile.neurocatch()
        fileObjects = device.init(device_version,scan_ID,local_path,dispIMG=False)
        rawEEG = fileObjects[0]
        rawEOG = fileObjects[1]
        filtering = filters()
        adaptiveFilterOutput = filtering.adaptive(rawEEG,rawEOG)
        notchFilterOutput = filtering.notch(adaptiveFilterOutput,line,fs)
        bandPassFilterOutput = filtering.butterBandPass(notchFilterOutput,lowcut,highcut,fs)
        bandPassFilterOutput = bandPassFilterOutput[0:155000]
        return bandPassFilterOutput
    chans = []
    for i in range(len(scan_IDs)):
        chans.append(fnc(device_version,scan_IDs[i],local_path,fs,line,lowcut,highcut))
    chans = np.array(chans)
    return chans

def avgBandPower(data,fs,low,high):
    #   Utilizes MultiTaper method to calculate the average power of a band
    #  Inputs  :   data    - 2D numpy array (d0 = samples, d1 = channels) of filtered EEG data
    #              fs      - sampling rate of hardware (defaults to config)
    #              low     - lower limit in Hz for the brain wave
    #              high    - upper limit in Hz for the brain wave
    #              win     - size of window to be used for sliding
    #   Output  :   3D array (columns of array,no of windows,window size)
    def absPower(data,fs,low,high): 
        psd, freqs = psd_array_multitaper(data, fs, adaptive=True,
                                            normalization='full', verbose=0)
        freq_res = freqs[1] - freqs[0]
        idx_band = np.logical_and(freqs >= low, freqs <= high)
        bp = simps(psd[idx_band], dx=freq_res)  
        return bp

    avg_BandPower = []
    for i in range(len(data.T)):
        avg_BandPower.append(absPower(data[:,i],fs,low,high))
    avg_BandPower= np.array(avg_BandPower).T
    return avg_BandPower

def RelBandPower(data,fs,low,high):
    #  Inputs  :   data    - 2D numpy array (d0 = samples, d1 = channels) of filtered EEG data
    #              fs      - sampling rate of hardware (defaults to config)
    #              low     - lower limit in Hz for the brain wave
    #              high    - upper limit in Hz for the brain wave
    #              win     - size of window to be used for sliding
    #   Output  :   3D array (columns of array,no of windows,window size)
    def absPower(data,fs,low,high): 
        win = 4*fs                                                
        freqs, psd = signal.welch(data,fs,nperseg=win)
        idx_freqBands = np.logical_and(freqs >= low, freqs <= high) 
        freq_res = freqs[1] - freqs[0]                                  
        freqBand_power = simps(psd[idx_freqBands],dx=freq_res)  
        total_power = simps(psd, dx=freq_res)
        freqBand_rel_power = freqBand_power / total_power
        return freqBand_rel_power
    rel_BandPower = []
    for i in range(len(data.T)):
        rel_BandPower.append(absPower(data[:,i],fs,low,high))
    rel_BandPower= np.array(rel_BandPower).T
    return rel_BandPower

def multipleSlidingWindow(input_3d,timing,window_size,step):
    """
    input_3d: 3d array of shape (n_subjects,n_samples,n_channels)
    timing: 1d array of shape (n_samples)
    window_size: int in seconds
    step: int in seconds
    output: 4d array of shape (n_subjects,n_channels,n_windows,window_size)
    """
    def slidingWindow(array,timing,window_size,step):
        #   Inputs  :   array    - 2D numpy array (d0 = samples, d1 = channels) of filtered EEG data
        #               window_size - size of window to be used for sliding
        #               freq   - step size for sliding window 
        #   Output  :   3D array (columns of array,no of windows,window size)
        def rolling_window(data_array,timing_array,window_size,step_size):
            idx_winSize = np.where(timing_array == window_size)[0][0]
            idx_stepSize = np.where(timing_array == step_size)[0][0]
            shape = (data_array.shape[0] - idx_winSize + 1, idx_winSize)
            strides = (data_array.strides[0],) + data_array.strides
            rolled = np.lib.stride_tricks.as_strided(data_array, shape=shape, strides=strides)
            return rolled[np.arange(0,shape[0],idx_stepSize)]
        out_final = []
        for i in range(len(array.T)):
            out_final.append(rolling_window(array[:,i],timing,window_size,step))
        out_final = np.asarray(out_final).T
        out_final = out_final.transpose()
        return out_final
    sw_out = []
    for i in range(input_3d.shape[0]):
        sw_out.append(slidingWindow(input_3d[i,:,:],timing,window_size,step))
    return np.array(sw_out)

def multipleEQI(filenames,version,localPath,threshold):
    def param_fnc(filename,version,localPath):
        device = importFile.neurocatch()
        fileObjects = device.init(version,filename,localPath,dispIMG=False)
        rawEEG = fileObjects[0]
        time = fileObjects[3]
        quality = signal_quality_index(rawEEG[:,1],time,filename,dispIMG=True)
        return quality
    scores = []
    for i in range(len(filenames)):
        scores.append(param_fnc(filenames[i],version,localPath))
    scores = np.array(scores)
    #rejected = scores == threshold
    #rejected = filenames[rejected]
    #accepted = scores > threshold
    #accepted = filenames[accepted]
    #return accepted,rejected
    return scores

def simIdx(filenames,threshold,verNumber,channel_names,filePath,fs,line,lowpass,highpass,stimTRIG,vClip):
    """
    verNumber: version number of the device
    channel_names: list of strings of channel names
    filenames: list of strings of filenames
    dataPath: string of the path to the data
    fs: sampling rate of the device
    line: line frequency of the device
    lowpass: lower limit of the bandpass filter
    highpass: upper limit of the bandpass filter
    stimTRIG: trigger channel for the stimulus
    vClip: voltage clipping level
    NB: Reducing the threshold value increases the number of accepted scan and viceversa for rejected scans
    """

    def scansERPs(version,chanNames,scan_IDs,path,sfreq,lineFreq,lowpass,highpass,stim_trig,clip_voltage):
        def generateERPs(device_version,chanNames,scan_ID,local_path,fs,line,lowcut,highcut,stimTrig,clip):
            device = importFile.neurocatch()
            fileObjects = device.init(device_version,scan_ID,local_path,dispIMG=False)
            rawEEG = fileObjects[0]
            rawEOG = fileObjects[1]
            time = fileObjects[3]
            trigOutput = fileObjects[4]
            filtering = filters()
            adaptiveFilterOutput = filtering.adaptive(rawEEG,rawEOG)
            notchFilterOutput = filtering.notch(adaptiveFilterOutput,line,fs)
            bandPassFilterOutput = filtering.butterBandPass(notchFilterOutput,lowcut,highcut,fs)
            erps = erpExtraction()
            N1P3 = erps.N100P300(chanNames,scan_ID,trigOutput,bandPassFilterOutput,time,stimTrig,clip,dispIMG=False)
            N4 = erps.N400(chanNames,scan_ID,trigOutput,bandPassFilterOutput,time,stimTrig,clip,dispIMG=False)
            N1P3_Cz,N4_Cz = N1P3[1],N4[1]
            dev_Cz = filtering.butter_lowpass(N1P3_Cz[1],cutoff=highcut,fs=fs,order=4)
            inc_Cz = filtering.butter_lowpass(N4_Cz[1],cutoff=highcut,fs=fs,order=4)
            return dev_Cz,inc_Cz
        dev_cz_scans = []
        inc_cz_scans = []
        for i in range(len(scan_IDs)):
            dev_cz_scans.append(generateERPs(device_version=version,chanNames=[chanNames[1]]*len(scan_IDs),scan_ID=scan_IDs[i],local_path=path,
                                            fs=sfreq,line=lineFreq,lowcut=lowpass,highcut=highpass,stimTrig=stim_trig,clip=clip_voltage)[0])
            inc_cz_scans.append(generateERPs(device_version=version,chanNames=[chanNames[1]]*len(scan_IDs),scan_ID=scan_IDs[i],local_path=path,
                                            fs=sfreq,line=lineFreq,lowcut=lowpass,highcut=highpass,stimTrig=stim_trig,clip=clip_voltage)[1])
        dev_cz_scans = np.array(dev_cz_scans)
        inc_cz_scans = np.array(inc_cz_scans)
        singles = np.hstack((dev_cz_scans,inc_cz_scans))
        grand = np.nanmean(singles,axis=0)
        return singles,grand
    def MSE(x, y):
        return np.sum((x - y)**2)/len(x)

    test = scansERPs(verNumber,channel_names,filenames,filePath,fs,line,lowpass,
                        highpass,stimTRIG,vClip)
    sngs,gnd = test[0],test[1]
    mse_scores = []
    for i in range(len(sngs)):
        mse_scores.append(MSE(gnd,sngs[i]))
    mse_scores = np.array(mse_scores)

    mean = numpy.nanmean(mse_scores, axis=0)
    sd = numpy.nanstd(mse_scores, axis=0)
    idx_accepted = np.where(mse_scores < mean - threshold * sd)[0]
    idx_rejected = np.where(mse_scores > mean - threshold * sd)[0]
    #filenames = filenames.to_numpy(dtype=object)
    accScans = filenames[idx_accepted]
    rejScans = filenames[idx_rejected]
    print("mean: ", mean)
    print("sd: ", sd)
    print("Max accepted score: ", np.max(mse_scores[idx_accepted]))
    print("Max rejected score: ", np.max(mse_scores[idx_rejected]))
    print("Min accepted score: ", np.min(mse_scores[idx_accepted]))
    print("Min rejected score: ", np.min(mse_scores[idx_rejected]))
    return accScans,rejScans

def rms(data):
    def param_fnc(data):
        output = np.sqrt(np.mean(np.square(data)))
        return output
    rms = []
    for i in range(len(data)):
        rms.append(param_fnc(data[i]))
    rms = np.array(rms)
    return rms

def kurt(data):
    def param_fnc(data):
        output = kurtosis(data)
        return output
    kurtosis_ = []
    for i in range(len(data)):
        kurtosis_.append(param_fnc(data[i]))
    kurtosis_ = np.array(kurtosis_)
    return kurtosis_

def sample_entropy(data):
    def param_fnc(data):
        import antropy as ant
        output = ant.sample_entropy(data)
        return output
    entropy = []
    for i in range(len(data)):
        entropy.append(param_fnc(data[i]))
    entropy = np.array(entropy)
    return entropy

def app_entropy(data):
    def param_fnc(data):
        import entropy as ent
        output = ent.app_entropy(data)
        return output
    entropy = []
    for i in range(len(data)):
        entropy.append(param_fnc(data[i]))
    entropy = np.array(entropy)
    return entropy

def rmsBandAmp(input,low,high,fs):
    def params(data,low,high,fs):
        filt = filters()
        bbp = filt.butterBandPass(data,low,high,fs)
        rms = np.sqrt(np.mean(np.square(bbp)))
        return rms
    output = []
    for i in range(len(input)):
        output.append(params(input[i],low,high,fs))
    return np.array(output)


dataPath = '/Users/joshuaighalo/Downloads/brainNet_datasets/bruyere/'
fileNamesPath = "/Users/joshuaighalo/Downloads/brainNet_datasets/bruyere/"
filenames = os.listdir(fileNamesPath)
filenames.remove('.DS_Store')
vNum = 1.1
low,high = 0.1,20
window_len,window_overlap = 1,1
delta,theta,alpha,beta,gamma = [0.5,4],[4,7],[8,12],[12.5,30],[30.5,45]


#     EQI ASSESSMENT: Pass scans through EQI
#  Inputs  :   scans - dataframe of scans
#              version - version of device
#              localPath - local path to files
#  Outputs :   scans_qf_1 - scans with quality score greater than zero
#              scans_df_1 - scans with quality score equal to zero
scans = filenames
quality = multipleEQI(scans,version=vNum,localPath=dataPath,threshold=0)
scans_qf_1 = quality
scans_qf_1 = scans_qf_1.to_numpy(dtype=object)
scans_dq_1 = quality[1]
scans_dq_1 = scans_dq_1.to_numpy(dtype=object)


#     SIMILARITY INDEX ASSESSMENT: Pass scans through Similarity Index
#  Inputs  :   scans - scans_qf_1
simIDX = simIdx(filenames=scans_qf_1,threshold=0.1,verNumber=1.0,channel_names=['Fz','Cz','Pz'],filePath=dataPath,
                fs=cfg.fs,line=cfg.line,lowpass=0.1,highpass=20,stimTRIG=cfg.stimTrig,vClip=cfg.clip)

scans_qf_2 = simIDX[0]
scans_dq_2 = simIDX[1]


#   Extract EEG from the qualified scans group and two rejcted scan groups
#  Inputs  :   scans_qf_2 - qualified scans
#              scans_dq_1 - rejected scans
#              scans_df_1 - rejected scans
#  Outputs :   eeg_qf_2 - EEG from qualified scans (n_subs x n_samples x n_channels)
#              eeg_dq_1 - EEG from rejected scans (n_subs x n_samples x n_channels)
#              eeg_dq_2 - EEG from rejected scans (n_subs x n_samples x n_channels)

eeg_qf_2 = multipleRawEEG(device_version=vNum,scan_IDs=scans_qf_2,local_path=dataPath,fs=cfg.fs,line=cfg.line,
                            lowcut=low,highcut=high)
eeg_dq_1 = multipleRawEEG(device_version=vNum,scan_IDs=scans_dq_1,local_path=dataPath,fs=cfg.fs,line=cfg.line,
                            lowcut=low,highcut=high)
eeg_dq_2 = multipleRawEEG(device_version=vNum,scan_IDs=scans_dq_2,local_path=dataPath,fs=cfg.fs,line=cfg.line,
                            lowcut=low,highcut=high)

time_s = np.arange(0, len(eeg_qf_2[0,:,:]) * 1/cfg.fs,1/cfg.fs)

#   Apply sliding window to the EEG data
#  Inputs  :   eeg_qf_2 - EEG from qualified scans (n_subs x n_samples x n_channels)
#              eeg_dq_1 - EEG from rejected scans (n_subs x n_samples x n_channels)
#              eeg_dq_2 - EEG from rejected scans (n_subs x n_samples x n_channels)
#  Outputs :   eeg_qf_2_win - EEG from qualified scans (n_subs x n_channels x n_windows x window size)
#              eeg_dq_1_win - EEG from rejected scans (n_subs x n_channels x n_windows x window size)
#              eeg_dq_2_win - EEG from rejected scans (n_subs x n_channels x n_windows x window size)
eeg_qf_2_win = multipleSlidingWindow(eeg_qf_2,time_s,window_len,window_overlap)
eeg_dq_1_win = multipleSlidingWindow(eeg_dq_1,time_s,window_len,window_overlap)
eeg_dq_2_win = multipleSlidingWindow(eeg_dq_2,time_s,window_len,window_overlap)

#   Seperate data based on channel locations
#  Inputs  :   eeg_qf_2_win - EEG from qualified scans (n_subs x n_channels x n_windows x window size)
#              eeg_dq_1_win - EEG from rejected scans (n_subs x n_channels x n_windows x window size)
#              eeg_dq_2_win - EEG from rejected scans (n_subs x n_channels x n_windows x window size)
#  NB      :   reshaping the output so windows of every subject are stacked on one another
#  Outputs :   frontal_qf_2_win - EEG from qualified scans ((n_subs*n_windows) x window size)
#              frontal_dq_1_win - EEG from rejected scans ((n_subs*n_windows) x window size)
#              frontal_dq_2_win - EEG from rejected scans ((n_subs*n_windows) x window size)
#              central_qf_2_win - EEG from qualified scans ((n_subs*n_windows) x window size)
#              central_dq_1_win - EEG from rejected scans ((n_subs*n_windows) x window size)
#              central_dq_2_win - EEG from rejected scans ((n_subs*n_windows) x window size)
#              parietal_qf_2_win - EEG from qualified scans ((n_subs*n_windows) x window size)
#              parietal_dq_1_win - EEG from rejected scans ((n_subs*n_windows) x window size)
#              parietal_dq_2_win - EEG from rejected scans ((n_subs*n_windows) x window size)


#   Fz
frontal_qf_2 = eeg_qf_2_win[:,0,:,:]
frontal_dq_1 = eeg_dq_1_win[:,0,:,:]
frontal_dq_2 = eeg_dq_2_win[:,0,:,:]
frontal_qf_2 = frontal_qf_2.reshape(frontal_qf_2.shape[0]*frontal_qf_2.shape[1],frontal_qf_2.shape[2])
frontal_dq_1 = frontal_dq_1.reshape(frontal_dq_1.shape[0]*frontal_dq_1.shape[1],frontal_dq_1.shape[2])
frontal_dq_2 = frontal_dq_2.reshape(frontal_dq_2.shape[0]*frontal_dq_2.shape[1],frontal_dq_2.shape[2])

#   Cz
central_qf_2 = eeg_qf_2_win[:,1,:,:]
central_dq_1 = eeg_dq_1_win[:,1,:,:]
central_dq_2 = eeg_dq_2_win[:,1,:,:]
central_qf_2 = central_qf_2.reshape(central_qf_2.shape[0]*central_qf_2.shape[1],central_qf_2.shape[2])
central_dq_1 = central_dq_1.reshape(central_dq_1.shape[0]*central_dq_1.shape[1],central_dq_1.shape[2])
central_dq_2 = central_dq_2.reshape(central_dq_2.shape[0]*central_dq_2.shape[1],central_dq_2.shape[2])

#   Pz
parietal_qf_2 = eeg_qf_2_win[:,2,:,:]
parietal_dq_1 = eeg_dq_1_win[:,2,:,:]
parietal_dq_2 = eeg_dq_2_win[:,2,:,:]
parietal_qf_2 = parietal_qf_2.reshape(parietal_qf_2.shape[0]*parietal_qf_2.shape[1],parietal_qf_2.shape[2])
parietal_dq_1 = parietal_dq_1.reshape(parietal_dq_1.shape[0]*parietal_dq_1.shape[1],parietal_dq_1.shape[2])
parietal_dq_2 = parietal_dq_2.reshape(parietal_dq_2.shape[0]*parietal_dq_2.shape[1],parietal_dq_2.shape[2])


#   Extract Features from the data

#   Average Band Power
delta_frontal_qf_2 = avgBandPower(frontal_qf_2.T,cfg.fs,delta[0],delta[1])
delta_frontal_dq_1 = avgBandPower(frontal_dq_1.T,cfg.fs,delta[0],delta[1])
delta_frontal_dq_2 = avgBandPower(frontal_dq_2.T,cfg.fs,delta[0],delta[1])
delta_central_qf_2 = avgBandPower(central_qf_2.T,cfg.fs,delta[0],delta[1])
delta_central_dq_1 = avgBandPower(central_dq_1.T,cfg.fs,delta[0],delta[1])
delta_central_dq_2 = avgBandPower(central_dq_2.T,cfg.fs,delta[0],delta[1])
delta_parietal_qf_2 = avgBandPower(parietal_qf_2.T,cfg.fs,delta[0],delta[1])
delta_parietal_dq_1 = avgBandPower(parietal_dq_1.T,cfg.fs,delta[0],delta[1])
delta_parietal_dq_2 = avgBandPower(parietal_dq_2.T,cfg.fs,delta[0],delta[1])

theta_frontal_qf_2 = avgBandPower(frontal_qf_2.T,cfg.fs,theta[0],theta[1])
theta_frontal_dq_1 = avgBandPower(frontal_dq_1.T,cfg.fs,theta[0],theta[1])
theta_frontal_dq_2 = avgBandPower(frontal_dq_2.T,cfg.fs,theta[0],theta[1])
theta_central_qf_2 = avgBandPower(central_qf_2.T,cfg.fs,theta[0],theta[1])
theta_central_dq_1 = avgBandPower(central_dq_1.T,cfg.fs,theta[0],theta[1])
theta_central_dq_2 = avgBandPower(central_dq_2.T,cfg.fs,theta[0],theta[1])
theta_parietal_qf_2 = avgBandPower(parietal_qf_2.T,cfg.fs,theta[0],theta[1])
theta_parietal_dq_1 = avgBandPower(parietal_dq_1.T,cfg.fs,theta[0],theta[1])
theta_parietal_dq_2 = avgBandPower(parietal_dq_2.T,cfg.fs,theta[0],theta[1])

alpha_frontal_qf_2 = avgBandPower(frontal_qf_2.T,cfg.fs,alpha[0],alpha[1])
alpha_frontal_dq_1 = avgBandPower(frontal_dq_1.T,cfg.fs,alpha[0],alpha[1])
alpha_frontal_dq_2 = avgBandPower(frontal_dq_2.T,cfg.fs,alpha[0],alpha[1])
alpha_central_qf_2 = avgBandPower(central_qf_2.T,cfg.fs,alpha[0],alpha[1])
alpha_central_dq_1 = avgBandPower(central_dq_1.T,cfg.fs,alpha[0],alpha[1])
alpha_central_dq_2 = avgBandPower(central_dq_2.T,cfg.fs,alpha[0],alpha[1])
alpha_parietal_qf_2 = avgBandPower(parietal_qf_2.T,cfg.fs,alpha[0],alpha[1])
alpha_parietal_dq_1 = avgBandPower(parietal_dq_1.T,cfg.fs,alpha[0],alpha[1])
alpha_parietal_dq_2 = avgBandPower(parietal_dq_2.T,cfg.fs,alpha[0],alpha[1])

beta_frontal_qf_2 = avgBandPower(frontal_qf_2.T,cfg.fs,beta[0],beta[1])
beta_frontal_dq_1 = avgBandPower(frontal_dq_1.T,cfg.fs,beta[0],beta[1])
beta_frontal_dq_2 = avgBandPower(frontal_dq_2.T,cfg.fs,beta[0],beta[1])
beta_central_qf_2 = avgBandPower(central_qf_2.T,cfg.fs,beta[0],beta[1])
beta_central_dq_1 = avgBandPower(central_dq_1.T,cfg.fs,beta[0],beta[1])
beta_central_dq_2 = avgBandPower(central_dq_2.T,cfg.fs,beta[0],beta[1])
beta_parietal_qf_2 = avgBandPower(parietal_qf_2.T,cfg.fs,beta[0],beta[1])
beta_parietal_dq_1 = avgBandPower(parietal_dq_1.T,cfg.fs,beta[0],beta[1])
beta_parietal_dq_2 = avgBandPower(parietal_dq_2.T,cfg.fs,beta[0],beta[1])

gamma_frontal_qf_2 = avgBandPower(frontal_qf_2.T,cfg.fs,gamma[0],gamma[1])
gamma_frontal_dq_1 = avgBandPower(frontal_dq_1.T,cfg.fs,gamma[0],gamma[1])
gamma_frontal_dq_2 = avgBandPower(frontal_dq_2.T,cfg.fs,gamma[0],gamma[1])
gamma_central_qf_2 = avgBandPower(central_qf_2.T,cfg.fs,gamma[0],gamma[1])
gamma_central_dq_1 = avgBandPower(central_dq_1.T,cfg.fs,gamma[0],gamma[1])
gamma_central_dq_2 = avgBandPower(central_dq_2.T,cfg.fs,gamma[0],gamma[1])
gamma_parietal_qf_2 = avgBandPower(parietal_qf_2.T,cfg.fs,gamma[0],gamma[1])
gamma_parietal_dq_1 = avgBandPower(parietal_dq_1.T,cfg.fs,gamma[0],gamma[1])
gamma_parietal_dq_2 = avgBandPower(parietal_dq_2.T,cfg.fs,gamma[0],gamma[1])

#   Relative Power

rDelta_frontal_qf_2 = RelBandPower(frontal_qf_2.T,cfg.fs,delta[0],delta[1])
rDelta_frontal_dq_1 = RelBandPower(frontal_dq_1.T,cfg.fs,delta[0],delta[1])
rDelta_frontal_dq_2 = RelBandPower(frontal_dq_2.T,cfg.fs,delta[0],delta[1])
rDelta_central_qf_2 = RelBandPower(central_qf_2.T,cfg.fs,delta[0],delta[1])
rDelta_central_dq_1 = RelBandPower(central_dq_1.T,cfg.fs,delta[0],delta[1])
rDelta_central_dq_2 = RelBandPower(central_dq_2.T,cfg.fs,delta[0],delta[1])
rDelta_parietal_qf_2 = RelBandPower(parietal_qf_2.T,cfg.fs,delta[0],delta[1])
rDelta_parietal_dq_1 = RelBandPower(parietal_dq_1.T,cfg.fs,delta[0],delta[1])
rDelta_parietal_dq_2 = RelBandPower(parietal_dq_2.T,cfg.fs,delta[0],delta[1])
rTheta_frontal_qf_2 = RelBandPower(frontal_qf_2.T,cfg.fs,theta[0],theta[1])
rTheta_frontal_dq_1 = RelBandPower(frontal_dq_1.T,cfg.fs,theta[0],theta[1])
rTheta_frontal_dq_2 = RelBandPower(frontal_dq_2.T,cfg.fs,theta[0],theta[1])
rTheta_central_qf_2 = RelBandPower(central_qf_2.T,cfg.fs,theta[0],theta[1])
rTheta_central_dq_1 = RelBandPower(central_dq_1.T,cfg.fs,theta[0],theta[1])
rTheta_central_dq_2 = RelBandPower(central_dq_2.T,cfg.fs,theta[0],theta[1])
rTheta_parietal_qf_2 = RelBandPower(parietal_qf_2.T,cfg.fs,theta[0],theta[1])
rTheta_parietal_dq_1 = RelBandPower(parietal_dq_1.T,cfg.fs,theta[0],theta[1])
rTheta_parietal_dq_2 = RelBandPower(parietal_dq_2.T,cfg.fs,theta[0],theta[1])
rAlpha_frontal_qf_2 = RelBandPower(frontal_qf_2.T,cfg.fs,alpha[0],alpha[1])
rAlpha_frontal_dq_1 = RelBandPower(frontal_dq_1.T,cfg.fs,alpha[0],alpha[1])
rAlpha_frontal_dq_2 = RelBandPower(frontal_dq_2.T,cfg.fs,alpha[0],alpha[1])
rAlpha_central_qf_2 = RelBandPower(central_qf_2.T,cfg.fs,alpha[0],alpha[1])
rAlpha_central_dq_1 = RelBandPower(central_dq_1.T,cfg.fs,alpha[0],alpha[1])
rAlpha_central_dq_2 = RelBandPower(central_dq_2.T,cfg.fs,alpha[0],alpha[1])
rAlpha_parietal_qf_2 = RelBandPower(parietal_qf_2.T,cfg.fs,alpha[0],alpha[1])
rAlpha_parietal_dq_1 = RelBandPower(parietal_dq_1.T,cfg.fs,alpha[0],alpha[1])
rAlpha_parietal_dq_2 = RelBandPower(parietal_dq_2.T,cfg.fs,alpha[0],alpha[1])
rBeta_frontal_qf_2 = RelBandPower(frontal_qf_2.T,cfg.fs,beta[0],beta[1])
rBeta_frontal_dq_1 = RelBandPower(frontal_dq_1.T,cfg.fs,beta[0],beta[1])
rBeta_frontal_dq_2 = RelBandPower(frontal_dq_2.T,cfg.fs,beta[0],beta[1])
rBeta_central_qf_2 = RelBandPower(central_qf_2.T,cfg.fs,beta[0],beta[1])
rBeta_central_dq_1 = RelBandPower(central_dq_1.T,cfg.fs,beta[0],beta[1])
rBeta_central_dq_2 = RelBandPower(central_dq_2.T,cfg.fs,beta[0],beta[1])
rBeta_parietal_qf_2 = RelBandPower(parietal_qf_2.T,cfg.fs,beta[0],beta[1])
rBeta_parietal_dq_1 = RelBandPower(parietal_dq_1.T,cfg.fs,beta[0],beta[1])
rBeta_parietal_dq_2 = RelBandPower(parietal_dq_2.T,cfg.fs,beta[0],beta[1])
rGamma_frontal_qf_2 = RelBandPower(frontal_qf_2.T,cfg.fs,gamma[0],gamma[1])
rGamma_frontal_dq_1 = RelBandPower(frontal_dq_1.T,cfg.fs,gamma[0],gamma[1])
rGamma_frontal_dq_2 = RelBandPower(frontal_dq_2.T,cfg.fs,gamma[0],gamma[1])
rGamma_central_qf_2 = RelBandPower(central_qf_2.T,cfg.fs,gamma[0],gamma[1])
rGamma_central_dq_1 = RelBandPower(central_dq_1.T,cfg.fs,gamma[0],gamma[1])
rGamma_central_dq_2 = RelBandPower(central_dq_2.T,cfg.fs,gamma[0],gamma[1])
rGamma_parietal_qf_2 = RelBandPower(parietal_qf_2.T,cfg.fs,gamma[0],gamma[1])
rGamma_parietal_dq_1 = RelBandPower(parietal_dq_1.T,cfg.fs,gamma[0],gamma[1])
rGamma_parietal_dq_2 = RelBandPower(parietal_dq_2.T,cfg.fs,gamma[0],gamma[1])

#   skewness
skew_frontal_qf_2 = skew(frontal_qf_2.T)
skew_frontal_dq_1 = skew(frontal_dq_1.T)
skew_frontal_dq_2 = skew(frontal_dq_2.T)
skew_central_qf_2 = skew(central_qf_2.T)
skew_central_dq_1 = skew(central_dq_1.T)
skew_central_dq_2 = skew(central_dq_2.T)
skew_parietal_qf_2 = skew(parietal_qf_2.T)
skew_parietal_dq_1 = skew(parietal_dq_1.T)
skew_parietal_dq_2 = skew(parietal_dq_2.T)

#   sample entropy
sampEN_frontal_qf_2 = sample_entropy(frontal_qf_2)
sampEN_frontal_dq_1 = sample_entropy(frontal_dq_1)
sampEN_frontal_dq_2 = sample_entropy(frontal_dq_2)
sampEN_central_qf_2 = sample_entropy(central_qf_2)
sampEN_central_dq_1 = sample_entropy(central_dq_1)
sampEN_central_dq_2 = sample_entropy(central_dq_2)
sampEN_parietal_qf_2 = sample_entropy(parietal_qf_2)
sampEN_parietal_dq_1 = sample_entropy(parietal_dq_1)
sampEN_parietal_dq_2 = sample_entropy(parietal_dq_2)

#   Standard deviation
std_frontal_qf_2 = np.std(frontal_qf_2,axis=1)
std_frontal_dq_1 = np.std(frontal_dq_1,axis=1)
std_frontal_dq_2 = np.std(frontal_dq_2,axis=1)
std_central_qf_2 = np.std(central_qf_2,axis=1)
std_central_dq_1 = np.std(central_dq_1,axis=1)
std_central_dq_2 = np.std(central_dq_2,axis=1)
std_parietal_qf_2 = np.std(parietal_qf_2,axis=1)
std_parietal_dq_1 = np.std(parietal_dq_1,axis=1)
std_parietal_dq_2 = np.std(parietal_dq_2,axis=1)

#   RMS
rms_frontal_qf_2 = rms(frontal_qf_2)
rms_frontal_dq_1 = rms(frontal_dq_1)
rms_frontal_dq_2 = rms(frontal_dq_2)
rms_central_qf_2 = rms(central_qf_2)
rms_central_dq_1 = rms(central_dq_1)
rms_central_dq_2 = rms(central_dq_2)
rms_parietal_qf_2 = rms(parietal_qf_2)
rms_parietal_dq_1 = rms(parietal_dq_1)
rms_parietal_dq_2 = rms(parietal_dq_2)

#   Kurtosis
kurt_frontal_qf_2 = kurtosis(frontal_qf_2,axis=1)
kurt_frontal_dq_1 = kurtosis(frontal_dq_1,axis=1)
kurt_frontal_dq_2 = kurtosis(frontal_dq_2,axis=1)
kurt_central_qf_2 = kurtosis(central_qf_2,axis=1)
kurt_central_dq_1 = kurtosis(central_dq_1,axis=1)
kurt_central_dq_2 = kurtosis(central_dq_2,axis=1)
kurt_parietal_qf_2 = kurtosis(parietal_qf_2,axis=1)
kurt_parietal_dq_1 = kurtosis(parietal_dq_1,axis=1)
kurt_parietal_dq_2 = kurtosis(parietal_dq_2,axis=1)

#   Approximate Entropy
appEnt_frontal_qf_2 = app_entropy(frontal_qf_2)
appEnt_frontal_dq_1 = app_entropy(frontal_dq_1)
appEnt_frontal_dq_2 = app_entropy(frontal_dq_2)
appEnt_central_qf_2 = app_entropy(central_qf_2)
appEnt_central_dq_1 = app_entropy(central_dq_1)
appEnt_central_dq_2 = app_entropy(central_dq_2)
appEnt_parietal_qf_2 = app_entropy(parietal_qf_2)
appEnt_parietal_dq_1 = app_entropy(parietal_dq_1)
appEnt_parietal_dq_2 = app_entropy(parietal_dq_2)

#   Frequency RMS
deltaRMS_frontal_qf_2 = rmsBandAmp(frontal_qf_2,delta[0],delta[1],cfg.fs)
deltaRMS_frontal_dq_1 = rmsBandAmp(frontal_dq_1,delta[0],delta[1],cfg.fs)
deltaRMS_frontal_dq_2 = rmsBandAmp(frontal_dq_2,delta[0],delta[1],cfg.fs)
deltaRMS_central_qf_2 = rmsBandAmp(central_qf_2,delta[0],delta[1],cfg.fs)
deltaRMS_central_dq_1 = rmsBandAmp(central_dq_1,delta[0],delta[1],cfg.fs)
deltaRMS_central_dq_2 = rmsBandAmp(central_dq_2,delta[0],delta[1],cfg.fs)
deltaRMS_parietal_qf_2 = rmsBandAmp(parietal_qf_2,delta[0],delta[1],cfg.fs)
deltaRMS_parietal_dq_1 = rmsBandAmp(parietal_dq_1,delta[0],delta[1],cfg.fs)
deltaRMS_parietal_dq_2 = rmsBandAmp(parietal_dq_2,delta[0],delta[1],cfg.fs)
thetaRMS_frontal_qf_2 = rmsBandAmp(frontal_qf_2,theta[0],theta[1],cfg.fs)
thetaRMS_frontal_dq_1 = rmsBandAmp(frontal_dq_1,theta[0],theta[1],cfg.fs)
thetaRMS_frontal_dq_2 = rmsBandAmp(frontal_dq_2,theta[0],theta[1],cfg.fs)
thetaRMS_central_qf_2 = rmsBandAmp(central_qf_2,theta[0],theta[1],cfg.fs)
thetaRMS_central_dq_1 = rmsBandAmp(central_dq_1,theta[0],theta[1],cfg.fs)
thetaRMS_central_dq_2 = rmsBandAmp(central_dq_2,theta[0],theta[1],cfg.fs)
thetaRMS_parietal_qf_2 = rmsBandAmp(parietal_qf_2,theta[0],theta[1],cfg.fs)
thetaRMS_parietal_dq_1 = rmsBandAmp(parietal_dq_1,theta[0],theta[1],cfg.fs)
thetaRMS_parietal_dq_2 = rmsBandAmp(parietal_dq_2,theta[0],theta[1],cfg.fs)
alphaRMS_frontal_qf_2 = rmsBandAmp(frontal_qf_2,alpha[0],alpha[1],cfg.fs)
alphaRMS_frontal_dq_1 = rmsBandAmp(frontal_dq_1,alpha[0],alpha[1],cfg.fs)
alphaRMS_frontal_dq_2 = rmsBandAmp(frontal_dq_2,alpha[0],alpha[1],cfg.fs)
alphaRMS_central_qf_2 = rmsBandAmp(central_qf_2,alpha[0],alpha[1],cfg.fs)
alphaRMS_central_dq_1 = rmsBandAmp(central_dq_1,alpha[0],alpha[1],cfg.fs)
alphaRMS_central_dq_2 = rmsBandAmp(central_dq_2,alpha[0],alpha[1],cfg.fs)
alphaRMS_parietal_qf_2 = rmsBandAmp(parietal_qf_2,alpha[0],alpha[1],cfg.fs)
alphaRMS_parietal_dq_1 = rmsBandAmp(parietal_dq_1,alpha[0],alpha[1],cfg.fs)
alphaRMS_parietal_dq_2 = rmsBandAmp(parietal_dq_2,alpha[0],alpha[1],cfg.fs)
betaRMS_frontal_qf_2 = rmsBandAmp(frontal_qf_2,beta[0],beta[1],cfg.fs)
betaRMS_frontal_dq_1 = rmsBandAmp(frontal_dq_1,beta[0],beta[1],cfg.fs)
betaRMS_frontal_dq_2 = rmsBandAmp(frontal_dq_2,beta[0],beta[1],cfg.fs)
betaRMS_central_qf_2 = rmsBandAmp(central_qf_2,beta[0],beta[1],cfg.fs)
betaRMS_central_dq_1 = rmsBandAmp(central_dq_1,beta[0],beta[1],cfg.fs)
betaRMS_central_dq_2 = rmsBandAmp(central_dq_2,beta[0],beta[1],cfg.fs)
betaRMS_parietal_qf_2 = rmsBandAmp(parietal_qf_2,beta[0],beta[1],cfg.fs)
betaRMS_parietal_dq_1 = rmsBandAmp(parietal_dq_1,beta[0],beta[1],cfg.fs)
betaRMS_parietal_dq_2 = rmsBandAmp(parietal_dq_2,beta[0],beta[1],cfg.fs)
gammaRMS_frontal_qf_2 = rmsBandAmp(frontal_qf_2,gamma[0],gamma[1],cfg.fs)
gammaRMS_frontal_dq_1 = rmsBandAmp(frontal_dq_1,gamma[0],gamma[1],cfg.fs)
gammaRMS_frontal_dq_2 = rmsBandAmp(frontal_dq_2,gamma[0],gamma[1],cfg.fs)
gammaRMS_central_qf_2 = rmsBandAmp(central_qf_2,gamma[0],gamma[1],cfg.fs)
gammaRMS_central_dq_1 = rmsBandAmp(central_dq_1,gamma[0],gamma[1],cfg.fs)
gammaRMS_central_dq_2 = rmsBandAmp(central_dq_2,gamma[0],gamma[1],cfg.fs)
gammaRMS_parietal_qf_2 = rmsBandAmp(parietal_qf_2,gamma[0],gamma[1],cfg.fs)
gammaRMS_parietal_dq_1 = rmsBandAmp(parietal_dq_1,gamma[0],gamma[1],cfg.fs)
gammaRMS_parietal_dq_2 = rmsBandAmp(parietal_dq_2,gamma[0],gamma[1],cfg.fs)


#   Construct the labels for the data
#   ones - accepted scans
#   zeros - rejected scans

label_acc = np.ones((len(alpha_frontal_qf_2),1))
label_rej = np.zeros((len(alpha_frontal_dq_1)+len(alpha_frontal_dq_2),1))
label = np.append(label_acc,label_rej)


#   Concatenate the data and labels

#   Average Power
frontalAvgDeltaPower = np.hstack((delta_frontal_qf_2,delta_frontal_dq_1,delta_frontal_dq_2))
centralAvgDeltaPower = np.hstack((delta_central_qf_2,delta_central_dq_1,delta_central_dq_2))
parietalAvgDeltaPower = np.hstack((delta_parietal_qf_2,delta_parietal_dq_1,delta_parietal_dq_2))
frontalAvgThetaPower = np.hstack((theta_frontal_qf_2,theta_frontal_dq_1,theta_frontal_dq_2))
centralAvgThetaPower = np.hstack((theta_central_qf_2,theta_central_dq_1,theta_central_dq_2))
parietalAvgThetaPower = np.hstack((theta_parietal_qf_2,theta_parietal_dq_1,theta_parietal_dq_2))
frontalAvgAlphaPower = np.hstack((alpha_frontal_qf_2,alpha_frontal_dq_1,alpha_frontal_dq_2))
centralAvgAlphaPower = np.hstack((alpha_central_qf_2,alpha_central_dq_1,alpha_central_dq_2))
parietalAvgAlphaPower = np.hstack((alpha_parietal_qf_2,alpha_parietal_dq_1,alpha_parietal_dq_2))
frontalAvgBetaPower = np.hstack((beta_frontal_qf_2,beta_frontal_dq_1,beta_frontal_dq_2))
centralAvgBetaPower = np.hstack((beta_central_qf_2,beta_central_dq_1,beta_central_dq_2))
parietalAvgBetaPower = np.hstack((beta_parietal_qf_2,beta_parietal_dq_1,beta_parietal_dq_2))
frontalAvgGammaPower = np.hstack((gamma_frontal_qf_2,gamma_frontal_dq_1,gamma_frontal_dq_2))
centralAvgGammaPower = np.hstack((gamma_central_qf_2,gamma_central_dq_1,gamma_central_dq_2))
parietalAvgGammaPower = np.hstack((gamma_parietal_qf_2,gamma_parietal_dq_1,gamma_parietal_dq_2))

#   Skewness    
frontalSkewness = np.hstack((skew_frontal_qf_2,skew_frontal_dq_1,skew_frontal_dq_2))
centralSkewness = np.hstack((skew_central_qf_2,skew_central_dq_1,skew_central_dq_2))
parietalSkewness = np.hstack((skew_parietal_qf_2,skew_parietal_dq_1,skew_parietal_dq_2))

#   Sample Entropy
frontalSampleEntropy = np.hstack((sampEN_frontal_qf_2,sampEN_frontal_dq_1,sampEN_frontal_dq_2))
centralSampleEntropy = np.hstack((sampEN_central_qf_2,sampEN_central_dq_1,sampEN_central_dq_2))
parietalSampleEntropy = np.hstack((sampEN_parietal_qf_2,sampEN_parietal_dq_1,sampEN_parietal_dq_2))

#   Standard Deviation
frontalStdDev = np.hstack((std_frontal_qf_2,std_frontal_dq_1,std_frontal_dq_2))
centralStdDev = np.hstack((std_central_qf_2,std_central_dq_1,std_central_dq_2))
parietalStdDev = np.hstack((std_parietal_qf_2,std_parietal_dq_1,std_parietal_dq_2))

#   RMS
frontalRMS = np.hstack((rms_frontal_qf_2,rms_frontal_dq_1,rms_frontal_dq_2))
centralRMS = np.hstack((rms_central_qf_2,rms_central_dq_1,rms_central_dq_2))
parietalRMS = np.hstack((rms_parietal_qf_2,rms_parietal_dq_1,rms_parietal_dq_2))

#   Kurtosis
frontalKurtosis = np.hstack((kurt_frontal_qf_2,kurt_frontal_dq_1,kurt_frontal_dq_2))
centralKurtosis = np.hstack((kurt_central_qf_2,kurt_central_dq_1,kurt_central_dq_2))
parietalKurtosis = np.hstack((kurt_parietal_qf_2,kurt_parietal_dq_1,kurt_parietal_dq_2))

#   Approximate Entropy
frontalApproxEntropy = np.hstack((appEnt_frontal_qf_2,appEnt_frontal_dq_1,appEnt_frontal_dq_2))
centralApproxEntropy = np.hstack((appEnt_central_qf_2,appEnt_central_dq_1,appEnt_central_dq_2))
parietalApproxEntropy = np.hstack((appEnt_parietal_qf_2,appEnt_parietal_dq_1,appEnt_parietal_dq_2))

#   Frequency RMS
deltaRMS_frontal = np.hstack((delta_frontal_qf_2,delta_frontal_dq_1,delta_frontal_dq_2))
thetaRMS_frontal = np.hstack((theta_frontal_qf_2,theta_frontal_dq_1,theta_frontal_dq_2))
alphaRMS_frontal = np.hstack((alpha_frontal_qf_2,alpha_frontal_dq_1,alpha_frontal_dq_2))
betaRMS_frontal = np.hstack((beta_frontal_qf_2,beta_frontal_dq_1,beta_frontal_dq_2))
gammaRMS_frontal = np.hstack((gamma_frontal_qf_2,gamma_frontal_dq_1,gamma_frontal_dq_2))

deltaRMS_central = np.hstack((delta_central_qf_2,delta_central_dq_1,delta_central_dq_2))
thetaRMS_central = np.hstack((theta_central_qf_2,theta_central_dq_1,theta_central_dq_2))
alphaRMS_central = np.hstack((alpha_central_qf_2,alpha_central_dq_1,alpha_central_dq_2))
betaRMS_central = np.hstack((beta_central_qf_2,beta_central_dq_1,beta_central_dq_2))
gammaRMS_central = np.hstack((gamma_central_qf_2,gamma_central_dq_1,gamma_central_dq_2))

deltaRMS_parietal = np.hstack((delta_parietal_qf_2,delta_parietal_dq_1,delta_parietal_dq_2))
thetaRMS_parietal = np.hstack((theta_parietal_qf_2,theta_parietal_dq_1,theta_parietal_dq_2))
alphaRMS_parietal = np.hstack((alpha_parietal_qf_2,alpha_parietal_dq_1,alpha_parietal_dq_2))
betaRMS_parietal = np.hstack((beta_parietal_qf_2,beta_parietal_dq_1,beta_parietal_dq_2))
gammaRMS_parietal = np.hstack((gamma_parietal_qf_2,gamma_parietal_dq_1,gamma_parietal_dq_2))

#   Relative Power
rDelta_frontal = np.hstack((rDelta_frontal_qf_2,rDelta_frontal_dq_1,rDelta_frontal_dq_2))
rTheta_frontal = np.hstack((rTheta_frontal_qf_2,rTheta_frontal_dq_1,rTheta_frontal_dq_2))
rAlpha_frontal = np.hstack((rAlpha_frontal_qf_2,rAlpha_frontal_dq_1,rAlpha_frontal_dq_2))
rBeta_frontal = np.hstack((rBeta_frontal_qf_2,rBeta_frontal_dq_1,rBeta_frontal_dq_2))
rGamma_frontal = np.hstack((rGamma_frontal_qf_2,rGamma_frontal_dq_1,rGamma_frontal_dq_2))

rDelta_central = np.hstack((rDelta_central_qf_2,rDelta_central_dq_1,rDelta_central_dq_2))
rTheta_central = np.hstack((rTheta_central_qf_2,rTheta_central_dq_1,rTheta_central_dq_2))
rAlpha_central = np.hstack((rAlpha_central_qf_2,rAlpha_central_dq_1,rAlpha_central_dq_2))
rBeta_central = np.hstack((rBeta_central_qf_2,rBeta_central_dq_1,rBeta_central_dq_2))
rGamma_central = np.hstack((rGamma_central_qf_2,rGamma_central_dq_1,rGamma_central_dq_2))

rDelta_parietal = np.hstack((rDelta_parietal_qf_2,rDelta_parietal_dq_1,rDelta_parietal_dq_2))
rTheta_parietal = np.hstack((rTheta_parietal_qf_2,rTheta_parietal_dq_1,rTheta_parietal_dq_2))
rAlpha_parietal = np.hstack((rAlpha_parietal_qf_2,rAlpha_parietal_dq_1,rAlpha_parietal_dq_2))
rBeta_parietal = np.hstack((rBeta_parietal_qf_2,rBeta_parietal_dq_1,rBeta_parietal_dq_2))
rGamma_parietal = np.hstack((rGamma_parietal_qf_2,rGamma_parietal_dq_1,rGamma_parietal_dq_2))


df = pd.DataFrame({'f_avgDelta':frontalAvgDeltaPower,'f_avgTheta':frontalAvgThetaPower,'f_avgAlpha':frontalAvgAlphaPower,
                    'f_avgBeta':frontalAvgBetaPower,'f_avgGamma':frontalAvgGammaPower,'c_avgDelta':centralAvgDeltaPower,
                    'c_avgTheta':centralAvgThetaPower,'c_avgAlpha':centralAvgAlphaPower,'c_avgBeta':centralAvgBetaPower,
                    'c_avgGamma':centralAvgGammaPower,'p_avgDelta':parietalAvgDeltaPower,'p_avgTheta':parietalAvgThetaPower,
                    'p_avgAlpha':parietalAvgAlphaPower,'p_avgBeta':parietalAvgBetaPower,'p_avgGamma':parietalAvgGammaPower,
                    'f_skew':frontalSkewness,'c_skew':centralSkewness,'p_skew':parietalSkewness,'f_sampEN':frontalSampleEntropy,
                    'c_sampEN':centralSampleEntropy,'p_sampEN':parietalSampleEntropy,'f_std':frontalStdDev,'c_std':centralStdDev,
                    'p_std':parietalStdDev,'f_rms':frontalRMS,'c_rms':centralRMS,'p_rms':parietalRMS,'f_kurt':frontalKurtosis,
                    'c_kurt':centralKurtosis,'p_kurt':parietalKurtosis,'f_approxEN':frontalApproxEntropy,'c_approxEN':centralApproxEntropy,
                    'p_approxEN':parietalApproxEntropy,'f_rmsDelta':deltaRMS_frontal,'f_rmsTheta':thetaRMS_frontal,'f_rmsAlpha':alphaRMS_frontal,
                    'f_rmsBeta':betaRMS_frontal,'f_rmsGamma':gammaRMS_frontal,'c_rmsDelta':deltaRMS_central,'c_rmsTheta':thetaRMS_central,
                    'c_rmsAlpha':alphaRMS_central,'c_rmsBeta':betaRMS_central,'c_rmsGamma':gammaRMS_central,'p_rmsDelta':deltaRMS_parietal,
                    'p_rmsTheta':thetaRMS_parietal,'p_rmsAlpha':alphaRMS_parietal,'p_rmsBeta':betaRMS_parietal,'p_rmsGamma':gammaRMS_parietal,
                    'f_rDelta':rDelta_frontal,'f_rTheta':rTheta_frontal,'f_rAlpha':rAlpha_frontal,'f_rBeta':rBeta_frontal,'f_rGamma':rGamma_frontal,
                    'c_rDelta':rDelta_central,'c_rTheta':rTheta_central,'c_rAlpha':rAlpha_central,'c_rBeta':rBeta_central,'c_rGamma':rGamma_central,
                    'p_rDelta':rDelta_parietal,'p_rTheta':rTheta_parietal,'p_rAlpha':rAlpha_parietal,'p_rBeta':rBeta_parietal,'p_rGamma':rGamma_parietal,
                    'class':label})

csv_dest_dir = '/Users/joshuaighalo/Documents/BrainNet/Projects/Workspace/Results/Laurel Place/ML Dataset/'
df.to_csv(csv_dest_dir+'testDataPrep.csv',index=False)